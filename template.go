package sbox

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"go.uber.org/zap"
)

// TemplateBuilder handles building custom Docker images with profiles
type TemplateBuilder struct {
	Config   *Config
	Profiles []string
}

// NewTemplateBuilder creates a new template builder
func NewTemplateBuilder(config *Config, profiles []string) *TemplateBuilder {
	return &TemplateBuilder{
		Config:   config,
		Profiles: profiles,
	}
}

// ProfilesHash computes a deterministic hash of the selected profiles (including dependencies)
func (tb *TemplateBuilder) ProfilesHash() string {
	// Resolve all profiles including dependencies
	resolved := tb.ResolveProfiles()

	// Sort profiles for deterministic hash
	sort.Strings(resolved)

	combined := strings.Join(resolved, ",")
	hash := sha256.Sum256([]byte(combined))
	return hex.EncodeToString(hash[:])[:12]
}

// ResolveProfiles returns the full list of profiles including all dependencies.
// Dependencies are listed before the profiles that depend on them.
func (tb *TemplateBuilder) ResolveProfiles() []string {
	seen := make(map[string]bool)
	var result []string

	var resolve func(name string)
	resolve = func(name string) {
		if seen[name] {
			return
		}

		profile, ok := GetProfile(name)
		if !ok {
			// Unknown profile, include it anyway (will error later)
			seen[name] = true
			result = append(result, name)
			return
		}

		// First resolve dependencies
		for _, dep := range profile.Dependencies {
			resolve(dep)
		}

		// Then add this profile
		seen[name] = true
		result = append(result, name)
	}

	for _, name := range tb.Profiles {
		resolve(name)
	}

	return result
}

// ImageName returns the Docker image name for this profile combination
func (tb *TemplateBuilder) ImageName() string {
	if len(tb.Profiles) == 0 {
		return "docker/sandbox-templates:claude-code"
	}
	return fmt.Sprintf("sbox-template:%s", tb.ProfilesHash())
}

// ImageExists checks if the custom image already exists
func (tb *TemplateBuilder) ImageExists() bool {
	imageName := tb.ImageName()
	if imageName == "docker/sandbox-templates:claude-code" {
		return true // Base image always "exists"
	}

	cmd := exec.Command("docker", "image", "inspect", imageName)
	err := cmd.Run()
	return err == nil
}

// GenerateDockerfile creates a Dockerfile with all selected profiles (including dependencies)
func (tb *TemplateBuilder) GenerateDockerfile() (string, error) {
	var sb strings.Builder

	sb.WriteString("# Auto-generated by sbox\n")
	sb.WriteString("FROM docker/sandbox-templates:claude-code\n\n")
	sb.WriteString("# Switch to root to install packages\n")
	sb.WriteString("USER root\n\n")

	// Use resolved profiles to include dependencies in correct order
	resolvedProfiles := tb.ResolveProfiles()

	for _, profileName := range resolvedProfiles {
		profile, ok := GetProfile(profileName)
		if !ok {
			return "", fmt.Errorf("unknown profile: %s", profileName)
		}

		sb.WriteString(fmt.Sprintf("# Profile: %s\n", profileName))
		sb.WriteString(fmt.Sprintf("# %s\n", profile.Description))
		sb.WriteString(profile.DockerfileSnippet)
		sb.WriteString("\n")
	}

	sb.WriteString("# Switch back to agent user\n")
	sb.WriteString("USER agent\n")

	return sb.String(), nil
}

// Build builds the custom Docker image with selected profiles
// Returns the image name to use
func (tb *TemplateBuilder) Build(forceRebuild bool) (string, error) {
	// If no profiles, use base image
	if len(tb.Profiles) == 0 {
		zlog.Debug("no profiles selected, using base image")
		return "docker/sandbox-templates:claude-code", nil
	}

	imageName := tb.ImageName()

	// Check if image already exists
	if !forceRebuild && tb.ImageExists() {
		zlog.Debug("using existing custom image",
			zap.String("image", imageName),
			zap.Strings("profiles", tb.Profiles))
		return imageName, nil
	}

	zlog.Info("building custom template image",
		zap.String("image", imageName),
		zap.Strings("profiles", tb.Profiles))

	// Create temporary directory for Dockerfile
	tempDir, err := os.MkdirTemp("", "sbox-template-")
	if err != nil {
		return "", fmt.Errorf("failed to create temp directory: %w", err)
	}
	defer os.RemoveAll(tempDir)

	// Generate Dockerfile
	dockerfile, err := tb.GenerateDockerfile()
	if err != nil {
		return "", fmt.Errorf("failed to generate Dockerfile: %w", err)
	}

	dockerfilePath := filepath.Join(tempDir, "Dockerfile")
	if err := os.WriteFile(dockerfilePath, []byte(dockerfile), 0644); err != nil {
		return "", fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	zlog.Debug("generated Dockerfile",
		zap.String("path", dockerfilePath),
		zap.Int("size", len(dockerfile)))

	// Build the image
	cmd := exec.Command("docker", "build", "-t", imageName, "-f", dockerfilePath, tempDir)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("docker build failed: %w", err)
	}

	zlog.Info("custom template image built successfully",
		zap.String("image", imageName))

	return imageName, nil
}

// CleanTemplates removes all cached sbox template images
func CleanTemplates() error {
	zlog.Info("cleaning cached template images")

	// List all sbox-template images
	cmd := exec.Command("docker", "images", "--filter", "reference=sbox-template:*", "--format", "{{.Repository}}:{{.Tag}}")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to list template images: %w", err)
	}

	images := strings.Split(strings.TrimSpace(string(output)), "\n")
	for _, image := range images {
		if image == "" {
			continue
		}

		zlog.Debug("removing template image", zap.String("image", image))
		rmCmd := exec.Command("docker", "rmi", image)
		if err := rmCmd.Run(); err != nil {
			zlog.Warn("failed to remove image",
				zap.String("image", image),
				zap.Error(err))
		}
	}

	return nil
}
